# -*- coding: utf-8 -*-
"""PRML_A1_Q2 ii.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1faPDbbytbj55RIA4VcJhTDyPMYlRIiz3

## Spectral Clustering , Relaxed version and custome method of Argmax
"""

from google.colab import files
import pandas as pd
import numpy as np
import io
import matplotlib.pyplot as plt
import random
import math
from scipy.spatial import Voronoi, voronoi_plot_2d
from sklearn.cluster import SpectralClustering

df = pd.read_csv('/content/cm_dataset_2 - cm_dataset.csv')
df.loc[999] = df.columns[0], df.columns[1]

df.columns = ['x', 'y']
df.describe()

plt.scatter(df['x'],df['y'], c = 'turquoise')
plt.scatter(df['x'],df['y'], c = 'k', s =1)

plt.title("Given Data - Plotted")
plt.xlabel("X")
plt.ylabel('Y')

plt.show()

k =  2 # K-means Cluster allocations
n = 1000 #data points

def compute_mean(x, z):
  μ = np.zeros((k,2))
  count = np.zeros((k,1))
  for i in range(len(x)):
    μ[int(z[i][0])-1] += x[i]
    count[(int)(z[i][0])-1] += 1
  for j in range(k):
    μ[j] = μ[j]/count[j]
  return μ

def best_cluster(x,z,mean):
  new_z = np.zeros((1000,1))
  for i in range(n):
    new_z[i] = np.argmin([np.linalg.norm(x[i]-mu) for mu in mean]) + 1
  return new_z

def errr(x,z,mean):         # error of current clustering from ideal k = n clustering
  e = 0
  for i in range(n):
    e += np.linalg.norm(x[i]-mean[int(z[i][0])-1])**2
  return e

def kmeans(x):
  z = np.zeros((1000,1))
  re_z = np.zeros((1000,1))
  err = []

  mean = np.zeros(k)                             # Generate k random means
  mean_re = random.sample([x_i for x_i in x], k)

  flag = np.array_equal(mean, mean_re)

  while(flag):
    mean = mean_re
    z = best_cluster(x, z, mean)
    mean_re = compute_mean(x,z)
    err.append(errr(x,z,mean_re))

  #plt.show()
  #print(mean)

  plt.plot(err)
  plt.ylabel('Error')
  plt.xlabel('Iteration')
  return z,mean

# UncCentered Datapoints
"""
df['x'] = pd.to_numeric(df['x'])
df['y'] = pd.to_numeric(df['y'])
x = df.to_numpy()
x =  x - np.mean(x, axis =0)"""

def kernelb(Map, σ):
  n = Map.shape[1]
  #print(n)
  rbf = np.zeros((n,n))
  one = (1/n)*np.ones((n,n))

  for i in range(n):
    for j in range(i,n):     #symmetric
      xval = Map[:,i]
      yval = Map[:,j]
      rbf[i][j] = (np.linalg.norm(xval - yval))**2
      rbf[j][i] = rbf[i][j]

  K  = np.exp(-rbf/(σ))
  K = K - one.dot(K) - K.dot(one) + one.dot(K).dot(one)
  return K

print(x.shape)

K = kernelb(x.T, 5)
eig_val, eig_vect = np.linalg.eig(K)
print(K)
idx = eig_val.argsort()[::-1]
eig_val = eig_val[idx]
eigvect = eig_vect[:,idx]
H = eig_vect[:,:k]
H = H.real
for i in range(H.shape[0]):
  H[i] = H[i]/np.linalg.norm(H[i])

H

def Spectral_clusterR():
  z = np.zeros(1000)
  for i in range(1000):
    if H[i,0]<-0.5:
      z[i] = 1

    else:
      z[i] = 0

  for i in range(n):
    plt.scatter(x[i][0], x[i][1], c = color[int(z[i])+2])
  plt.xlim(-18,18)
  plt.ylim(-12,12)
  plt.xlabel('X')
  plt.ylabel('Y')

"""#### Spectral Clustering"""

kerv, kerm = kmeans(H.T)

#print(z_kernel2)
color = ['r', 'b', 'c', 'g', 'y']
for i in range(n):
  plt.scatter(x[i][0], x[i][1], c = color[int(kerv[i])+2])
plt.xlim(-18,18)
plt.ylim(-12,12)
plt.xlabel('X')
plt.ylabel('Y')

"""#### Relaxed version of Spectral Clustering"""

Spectral_clusterR()

"""#### Custom Argmax function"""

kerv = np.argmax(H, axis = 1)
color = ['r', 'b', 'c', 'g', 'y']
for i in range(n):
  plt.scatter(x[i][0], x[i][1], c = color[(int)(kerv[i])-1])
plt.xlabel('X')
plt.ylabel('Y')

